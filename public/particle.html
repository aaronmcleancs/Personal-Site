<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Showcase - ParticleBox</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/showcase.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <script src="https://kit.fontawesome.com/ca7f2ffa51.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="navbar">
        <div class="logo">
            <div class="icon"><img src="images/blurIcon.png" height="27px" width="27px" alt="Logo"></div>
        </div>
        <a href="index.html">Home</a>
        <a href="#overview">Overview</a>
        <a href="#features">Features</a>
        <a href="#particle-implementation">Particle Implementation</a>
        <a href="#physics-engine">Physics Engine</a>
        <a href="#performance">Performance</a>
        <a href="#gallery">Gallery</a>
    </div>

    <div class="showcase__hero">
        <div class="showcase__wrapper">
            <h1 class="animate__animated animate__fadeIn">ParticleBox</h1>
            <p class="animate__animated animate__fadeIn animate__delay-1s">A highly optimized, real-time particle simulation engine.</p>
        </div>
    </div>

    <div class="showcase__content">
        <section id="overview" class="showcase__section">
            <h2>Overview</h2>
            <p>ParticleBox is a C++-based, SDL2-accelerated particle simulator designed for real-time physics visualization. It simulates large swarms of particles interacting via forces such as gravity, repulsion, and boundary collisions.</p>
            <p>To handle high particle counts efficiently, ParticleBox combines:</p>
            <ul>
                <li><strong>Spatial Partitioning:</strong> Grid-based spatial hashing to reduce collision checks from \( \mathcal{O}(n^2) \) to approximately \( \mathcal{O}(n) \).</li>
                <li><strong>Multithreading:</strong> Parallel computation of particle updates, fully utilizing multi-core processors.</li>
                <li><strong>Efficient Data Structures:</strong> Memory pre-allocation and careful data layout to improve cache locality and reduce overhead.</li>
            </ul>
        </section>
    
        <section id="features" class="showcase__section">
            <h2>Key Techniques</h2>
            <ul>
                <li><strong>Multi-Core Parallelism:</strong> Leveraging <code>std::async</code> and multiple threads to update particle subsets in parallel.</li>
                <li><strong>Spatial Hashing & Grid Partitioning:</strong> Assigning particles to grid cells, ensuring only local neighbors are considered for collisions.</li>
                <li><strong>Reduced Pairwise Comparisons:</strong> Disabling certain checks or limiting neighbor ranges to cut down computational overhead.</li>
                <li><strong>Efficient Collision Response:</strong> Direct vector arithmetic and precomputed normals for quick, stable resolution of overlaps.</li>
                <li><strong>Dynamic Toggle Features:</strong> Runtime-configurable options for gravity, grid partitioning, and multithreading for optimal performance.</li>
            </ul>
        </section>
        
        <section id="particle-implementation" class="showcase__section">
            <h2>Particle Implementation</h2>
            <p>At the core of our simulation are the individual particles, each with properties that determine their behavior in the system. The <code>Particle</code> class encapsulates the physics and rendering logic for a single simulation element.</p>
            
            <h3>Core Particle Attributes</h3>
            <p>Each particle tracks essential state information:</p>
            <ul>
                <li><strong>Position and Velocity:</strong> 2D vectors representing the particle's current location and movement.</li>
                <li><strong>Mass and Inverse Mass:</strong> Pre-calculated for efficient force calculations.</li>
                <li><strong>Radius:</strong> Defines the particle's size and collision boundary.</li>
                <li><strong>Visual Properties:</strong> Color and rendering parameters for visualization.</li>
            </ul>
            
            <h3>Physics Update Logic</h3>
            <p>The particle update cycle implements basic Newtonian physics:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void Particle::update(const Vec2& force, float deltaTime) {
    Vec2 acceleration = force * invMass;
    velocity += acceleration * deltaTime; 
    position += velocity * deltaTime;
}
                </code></pre>
            </div>
            <p>This semi-implicit Euler integration provides a good balance between stability and computational efficiency for real-time simulations.</p>
            
            <h3>Velocity-Based Rendering</h3>
            <p>Particles use velocity-based coloring to provide visual feedback about the system's dynamics:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void Particle::render(SDL_Renderer* renderer) {
    // Error checking omitted for brevity
    
    float speed = std::sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
    SDL_Color blue = {40, 40, 255, 255};
    SDL_Color orange = {200, 20, 20, 55};
    float maxSpeed = 50.0f; 
    float normSpeed = std::min(speed / maxSpeed, 1.0f);

    SDL_Color color;
    color.r = static_cast<Uint8>(blue.r + normSpeed * (orange.r - blue.r));
    color.g = static_cast<Uint8>(blue.g + normSpeed * (orange.g - blue.g));
    color.b = static_cast<Uint8>(blue.b + normSpeed * (orange.b - blue.b));
    color.a = 255;

    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255);
    drawCircle(renderer, static_cast<int>(position.x), static_cast<int>(position.y), static_cast<int>(radius));
}
                </code></pre>
            </div>
            <p>This approach creates a dynamic visual effect where faster-moving particles shift from blue to orange, providing immediate insight into the system's energy distribution.</p>
            
            <h3>Optimized Circle Rendering</h3>
            <p>The circle rendering algorithm uses a simple but efficient distance-based approach:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void Particle::drawCircle(SDL_Renderer* renderer, int centerX, int centerY, int radius) {
    for (int w = 0; w < radius * 2; w++) {
        for (int h = 0; h < radius * 2; h++) {
            int dx = radius - w;  
            int dy = radius - h;  
            if ((dx * dx + dy * dy) <= (radius * radius)) {
                SDL_RenderDrawPoint(renderer, centerX + dx, centerY + dy);
            }
        }
    }
}
                </code></pre>
            </div>
            <p>While more sophisticated approaches exist (like Bresenham's algorithm for circle rasterization), this method works well for the small particle sizes in our simulation.</p>
            
            <h3>Defensive Programming</h3>
            <p>The implementation uses robust error checking to prevent simulation crashes from floating-point errors:</p>
            <ul>
                <li><strong>Null Pointer Validation:</strong> Checks for valid renderer references before attempting to draw.</li>
                <li><strong>NaN Detection:</strong> Guards against invalid physical states that could propagate errors.</li>
                <li><strong>Value Normalization:</strong> Ensures color values and other parameters stay within valid ranges.</li>
            </ul>
        </section>
    
        <section id="physics-engine" class="showcase__section">
            <h2>Physics Engine Design</h2>
            <p>The physics engine provides the computational backbone for particle interactions. It handles force calculations, collision detection, and position updates with a focus on performance.</p>
            
            <h3>Grid-Based Collision Detection</h3>
            <p>The heart of the physics engine uses spatial partitioning to efficiently find potential collisions:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
std::vector<Vec2> PhysicsEngine::computeForces(std::vector<Particle>& particles, int start, int end) {
    std::vector<Vec2> forces(end - start, Vec2(0, 0));

    if (gridEnabled) {
        const float cellSize = 8.0f;
        const int windowWidth = 1200;
        const int windowHeight = 800;
        const int gridWidth = static_cast<int>(std::ceil(windowWidth / cellSize));
        const int gridHeight = static_cast<int>(std::ceil(windowHeight / cellSize));

        std::vector<std::vector<int>> cells(gridWidth * gridHeight);
        for (int i = start; i < end; ++i) {
            int cellX = static_cast<int>(particles[i].position.x / cellSize);
            int cellY = static_cast<int>(particles[i].position.y / cellSize);
            if (cellX < 0) cellX = 0;
            if (cellX >= gridWidth) cellX = gridWidth - 1;
            if (cellY < 0) cellY = 0;
            if (cellY >= gridHeight) cellY = gridHeight - 1;
            cells[cellY * gridWidth + cellX].push_back(i);
        }
        
        // Force calculations follow...
    }
}
                </code></pre>
            </div>
            <p>This approach divides the simulation space into a grid of cells, assigning each particle to a cell based on its position. During collision detection, only particles in adjacent cells need to be considered, dramatically reducing the number of comparisons.</p>
            
            <h3>Collision Response</h3>
            <p>When collisions are detected, the engine calculates appropriate repulsion forces:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
Vec2 direction = particles[j].position - particles[i].position;
float distanceSq = direction.x * direction.x + direction.y * direction.y;
float combinedRadius = particles[i].radius + particles[j].radius;
float combinedRadiusSq = combinedRadius * combinedRadius;

if (distanceSq < combinedRadiusSq && distanceSq > 0.0f) {
    float distance = std::sqrt(distanceSq);
    Vec2 normal = direction / distance;
    float overlap = combinedRadius - distance;
    
    Vec2 repulsionForce = normal * (repulsionStrength * overlap);

    netForce -= repulsionForce; 
    
    if (j >= start && j < end) {
        forces[j - start] += repulsionForce; 
    }
}
                </code></pre>
            </div>
            <p>This simplified impulse-based model provides convincing physical behavior while remaining computationally efficient.</p>
            
            <h3>Boundary Handling</h3>
            <p>The simulation ensures particles remain within the visible area:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void PhysicsEngine::applyBoundaries(Particle& particle) {
    const int windowWidth = 1200;
    const int windowHeight = 800;
    const float velocityLossFactor = 0.9f;

    if (particle.position.x > windowWidth) {
        particle.position.x = windowWidth; 
        particle.velocity.x *= -velocityLossFactor;
    }

    if (particle.position.x < 0) {
        particle.position.x = 0; 
        particle.velocity.x *= -velocityLossFactor;
    }

    if (particle.position.y < 0) {
        particle.position.y = 0; 
        particle.velocity.y *= -velocityLossFactor;
    }

    if (particle.position.y > windowHeight) {
        particle.position.y = windowHeight; 
        particle.velocity.y *= -velocityLossFactor;
    }
}
                </code></pre>
            </div>
            <p>This code creates elastic boundary collisions with a slight energy loss, preventing particles from escaping while adding realistic damping effects.</p>
        </section>
        
        <section id="performance" class="showcase__section">
            <h2>Performance Optimization</h2>
            
            <h3>Multithreading Implementation</h3>
            <p>ParticleBox divides the workload across multiple threads, each handling a subset of particles:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void Simulation::update(double deltaTime) {
    if (!running) return;

    unsigned int numThreads = std::thread::hardware_concurrency();
    if (numThreads == 0) {
        numThreads = 4;
    }
    
    const size_t totalParticles = particles.size();
    if (totalParticles == 0) {
        calculateFrameRate();
        return;
    }

    if (multithreadingEnabled) {
        const size_t chunkSize = (totalParticles + numThreads - 1) / numThreads;
        std::vector<std::future<void>> futures;
        futures.reserve(numThreads);

        auto updateChunk = [this, deltaTime](size_t start, size_t end) {
            if (end <= start) return;
            std::vector<Vec2> forces = physics.computeForces(particles, static_cast<int>(start), static_cast<int>(end));
            for (size_t i = start; i < end; ++i) {
                Particle &p = particles[i];
                p.velocity.x += (forces[i - start].x * p.invMass) * (float)deltaTime;
                p.velocity.y += (forces[i - start].y * p.invMass) * (float)deltaTime;
                p.position.x += p.velocity.x * (float)deltaTime;
                p.position.y += p.velocity.y * (float)deltaTime;

                physics.applyBoundaries(p);
            }
        };

        size_t processed = 0;
        for (unsigned int i = 0; i < numThreads; ++i) {
            const size_t start = processed;
            const size_t end = std::min(start + chunkSize, totalParticles);
            processed = end;
            if (start < end) {
                futures.push_back(std::async(std::launch::async, updateChunk, start, end));
            } else {
                break;
            }
        }

        for (auto& future : futures) {
            future.get();
        }
    }
    // Single-threaded fallback code follows...
}
                </code></pre>
            </div>
            <p>This approach nearly linearly scales the simulation speed with the number of available CPU cores.</p>
            
            <h3>Memory Management &amp; Data Locality</h3>
            <p>Several techniques are employed to optimize memory usage:</p>
            <ul>
                <li><strong>Pre-allocation:</strong> Reserving vector capacity reduces reallocation costs during runtime.</li>
                <li><strong>Thread-Local Random Number Generation:</strong> Prevents contention between threads generating random particles.</li>
                <li><strong>Precalculated Inverse Mass:</strong> Storing inverse mass eliminates division operations in the inner loops.</li>
                <li><strong>Contiguous Memory:</strong> Using std::vector for particle storage improves cache utilization.</li>
            </ul>
            
            <h3>Configurable Optimizations</h3>
            <p>The simulation provides runtime-toggleable optimizations:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
Simulation::Simulation() 
    : running(false), 
      frameCount(0), 
      frameRate(0.0f),
      multithreadingEnabled(true), 
      gridEnabled(true),
      reducedPairwiseComparisonsEnabled(true) 
{
    // Initialization code
    physics.setGridEnabled(gridEnabled);
    physics.setReducedPairwiseComparisonsEnabled(reducedPairwiseComparisonsEnabled);
}
                </code></pre>
            </div>
            <p>These toggles allow for performance tuning based on the specific hardware capabilities and simulation requirements.</p>
            
            <h3>Performance Monitoring</h3>
            <p>The simulation tracks its own performance to help identify bottlenecks:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void Simulation::calculateFrameRate() {
    static std::chrono::steady_clock::time_point frameRateStartTime = std::chrono::steady_clock::now();
    frameCount++;

    auto currentTime = std::chrono::steady_clock::now();
    double secondsPassed = std::chrono::duration_cast<std::chrono::duration<double>>(currentTime - frameRateStartTime).count();

    if (secondsPassed >= 1.0) {
        frameRate = frameCount / (float)secondsPassed;
        frameCount = 0;
        frameRateStartTime = currentTime;
    }
}
                </code></pre>
            </div>
            <p>This real-time performance monitoring helps evaluate the effectiveness of different optimization strategies.</p>
        </section>
    
        <section id="project-detail" class="showcase__section">
            <h2>Mathematical Foundation</h2>
            
            <h3>Collision Detection Mathematics</h3>
            <p>For colliding particles, the distance \(d\) between particles is computed as:</p>
            <p>
                \[
                d = \sqrt{(p2.x - p1.x)^2 + (p2.y - p1.y)^2}
                \]
            </p>
            <p>A collision occurs when \(d < (r1 + r2)\), where \(r1\) and \(r2\) are the radii of the particles.</p>
            
            <h3>Force Calculation</h3>
            <p>The repulsion force magnitude \(F_r\) between overlapping particles is given by:</p>
            <p>
                \[
                F_r = k_{rep} \cdot \delta
                \]
            </p>
            <p>Where \(\delta\) is the overlap distance \((r1 + r2) - d\), and \(k_{rep}\) is the repulsion strength constant.</p>
            
            <h3>Integration Method</h3>
            <p>The simulation uses semi-implicit Euler integration, updating velocity first, then position:</p>
            <p>
                \[
                \mathbf{v}_{t+\Delta t} = \mathbf{v}_t + \mathbf{a}_t \cdot \Delta t
                \]
                \[
                \mathbf{p}_{t+\Delta t} = \mathbf{p}_t + \mathbf{v}_{t+\Delta t} \cdot \Delta t
                \]
            </p>
            <p>This method provides better stability than explicit Euler integration while remaining computationally efficient.</p>
        </section>
    
        <section id="simulation-features" class="showcase__section">
            <h2>Advanced Simulation Features</h2>
            <p>Beyond the core physics engine, ParticleBox includes several advanced features that enhance its usability and flexibility.</p>
            
            <h3>Dynamic Particle Generation</h3>
            <p>The simulation allows for generating new particles at runtime:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
void Simulation::spawnParticlesAtMouse(int x, int y, int count) {
    particles.reserve(particles.size() + (size_t)count);
    for (int i = 0; i < count; ++i) {
        particles.push_back(createParticleAtPosition(x, y));
    }
}

Particle Simulation::createParticleAtPosition(int x, int y) {
    // Random initialization code omitted for brevity
    Vec2 pos(static_cast<float>(x), static_cast<float>(y));
    float angle = distAngle(rng);
    float speed = distSpeed(rng);

    Vec2 vel(std::cos(angle) * speed, std::sin(angle) * speed);

    SDL_Color color = {
        static_cast<Uint8>(distColor(rng)),
        static_cast<Uint8>(distColor(rng)),
        static_cast<Uint8>(distColor(rng)),
        255
    };

    float radius = 2.0f;
    float mass = radius / 2.0f; 
    float dipoleMoment = 0.0f;
    float exclusionConstant = 0.0f;
    float repulsionFactor = 1.0f;
    int type = 0;

    return Particle(pos, vel, color, radius, mass, dipoleMoment, exclusionConstant, repulsionFactor, type);
}
                </code></pre>
            </div>
            <p>This feature allows for interactive simulation manipulation, such as adding particles at the cursor location.</p>
            
            <h3>Frame Rate Control</h3>
            <p>To ensure consistent simulation behavior across different hardware, ParticleBox implements frame rate limiting:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
auto currentTime = std::chrono::steady_clock::now();
auto frameDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
    currentTime - lastFrameTime
);

constexpr int targetFrameDuration = 16;  // Target ~60 FPS
if (frameDuration.count() < targetFrameDuration) {
    std::this_thread::sleep_for(
        std::chrono::milliseconds(targetFrameDuration - frameDuration.count())
    );
}
                </code></pre>
            </div>
            <p>This approach prevents the simulation from running too fast on high-performance systems while maintaining smooth animation.</p>
            
            <h3>Thread-Safe Random Number Generation</h3>
            <p>To support multithreaded particle creation, the simulation uses thread-local random number generators:</p>
            <div class="code-sample">
                <pre><code class="language-cpp">
static thread_local std::mt19937 rng(static_cast<unsigned>(std::time(nullptr)) ^ 
                                     static_cast<unsigned>(std::hash<std::thread::id>{}(std::this_thread::get_id())));
                </code></pre>
            </div>
            <p>This technique prevents contention between threads while ensuring that each thread's random sequence is properly seeded.</p>
        </section>

        <section id="gallery" class="showcase__section">
            <h2>Visual Examples</h2>
            <div class="image-gallery">
                <img src="images/p1.gif" alt="Particle simulation animation">
                <img src="images/p2.png" alt="Particle simulation screenshot">
            </div>
        </section>
    </div>

    <div class="showcase__cta">
        <a href="https://github.com/aaronmcleancs/ParticleBox" class="button">View on GitHub</a>
        <a href="#" class="button">Live Demo</a>
    </div>
    <div style="text-align: center; margin-top: 20px; margin-bottom: 20px;">
        <a href="https://opensource.org/licenses/MIT" style="color: rgb(113, 113, 113); font-size: small;" target="_blank;">
            Â© Aaron McLean
        </a>
    </div>
    <div class="fullscreen-viewer">
        <img src="" alt="Fullscreen image" class="fullscreen-image">
        <div class="fullscreen-nav">
            <button class="fullscreen-prev">&lt;</button>
            <button class="fullscreen-next">&gt;</button>
        </div>
        <button class="fullscreen-close">&times;</button>
    </div>

    <script src="js/photo.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
</body>
</html>