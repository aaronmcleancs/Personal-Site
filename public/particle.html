<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Showcase - ParticleBox</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/showcase.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <script src="https://kit.fontawesome.com/ca7f2ffa51.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="navbar">
        <div class="logo">
            <div class="icon"><img src="images/blurIcon.png" height="27px" width="27px" alt="Logo"></div>
        </div>
        <a href="index.html">Home</a>
        <a href="#overview">Overview</a>
    </div>

    <div class="showcase__hero">
        <div class="showcase__wrapper">
            <h1 class="animate__animated animate__fadeIn">ParticleBox</h1>
            <p class="animate__animated animate__fadeIn animate__delay-1s">Multithreaded particle simulation engine for real-time physics interactions.</p>
        </div>
    </div>

    <div class="showcase__content">
        <section id="overview" class="showcase__section">
            <h2>Project Overview</h2>
            <p>ParticleBox is a robust particle dynamics engine implemented in C++ with SDL2. It's crafted for real-time visualization of complex forces such as repulsion, thermodynamics, and gravity among hundreds of thousands of particles. By employing a grid-based multithreaded rendering approach, this project achieves remarkable efficiency, central to the underlying computational theory and physical models.</p>
        </section>

        <section id="features" class="showcase__section">
            <h2>Key Features</h2>
            <ul>
                <li>Real-time visualization of particle dynamics with multithreading support.</li>
                <li>Simulation of various physical interactions, including gravity and repulsion.</li>
                <li>Efficient handling of high particle counts (up to 100,000+).</li>
                <li>Potential for fluid simulation using particle-based methods.</li>
            </ul>
        </section>
        <section id="project-detail" class="showcase__section">
            <h2>Project Detail</h2>
            <p>ParticleBox is a high-performance particle simulation engine that utilizes multithreading techniques to ensure smooth, real-time performance with up to 100,000 particles. The engine leverages multiple CPU cores to handle updates to particle positions and forces concurrently, essential for running large-scale simulations efficiently.</p>
    
            <h3>Multithreading Implementation</h3>
            <p>ParticleBox's multithreading method is critical to optimizing particle updates. By using `std::async` and demarcating work into chunks, ParticleBox significantly enhances the processing speed of simulations, reducing bottlenecks typically encountered with single-threaded computations.</p>
            <div class="code-sample">
                <pre><code class="language-javascript">
                    void Simulation::update(double deltaTime) {
                        if (!running) return;
                    
                        int numThreads = 24;
                        std::vector<std::future<void>> futures;
                    
                        auto updateChunk = [this, deltaTime](int start, int end) {
                            std::vector<Vec2> forces = physics.computeForces(particles, start, end);
                            for (int i = start; i < end; ++i) {
                                particles[i].update(forces[i-start], deltaTime);
                                physics.applyBoundaries(particles[i]);
                            }
                        };
                    
                        int chunkSize = particles.size() / numThreads;
                        for (int i = 0; i < numThreads; ++i) {
                            int start = i * chunkSize;
                            int end = (i == numThreads - 1) ? particles.size() : (start + chunkSize);
                            futures.push_back(std::async(std::launch::async, updateChunk, start, end));
                        }
                    
                        for (auto &future : futures) {
                            future.get();
                        }
                    
                        calculateFrameRate();
                    
                        /*Frame Rate Regulation - Comment out to cap CPU
                    
                        auto currentTime = std::chrono::steady_clock::now();
                        auto frameDuration = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - lastFrameTime);
                    
                        const int targetFrameDuration = 16;
                    
                        if (frameDuration.count() < targetFrameDuration) {
                            std::this_thread::sleep_for(std::chrono::milliseconds(targetFrameDuration - frameDuration.count()));
                        }
                    
                        lastFrameTime = std::chrono::steady_clock::now();
                        */
                        
                    }

</code></pre>
</div>
<p>This code illustrates the partitioning of particle updates into distinct segments. Utilizing separate threads for each chunk allows ParticleBox to concurrently perform computations, vastly improving simulation speed through parallel processing.</p>
<h3>Fluid Simulation Potential</h3>
        <p>While primarily a particle engine, ParticleBox's architecture allows for implementation of advanced fluid simulation techniques:</p>
        <ul>
            <li><strong>Smoothed Particle Hydrodynamics (SPH):</strong> Interpolates fluid properties using kernel functions, suitable for simulating liquids and gases.</li>
            <li><strong>Position Based Dynamics (PBD):</strong> Iteratively adjusts particle positions to satisfy constraints, providing stable simulations even with large time steps.</li>
            <li><strong>Lattice Boltzmann Method (LBM):</strong> Discretizes space into a lattice of particles, highly parallelizable and suitable for GPU acceleration.</li>
        </ul>
        <p>The high particle count capability of ParticleBox (100,000+) enables detailed fluid simulations with fine-grained surface details, complex interactions between multiple fluid bodies, and realistic behavior of splashes, droplets, and waves.</p>

        <h3>Theoretical Computer Science and Optimization</h3>
        <p>ParticleBox leverages key principles in computer science to achieve its performance:</p>
        <ul>
            <li><strong>Data Parallelism:</strong> Allows simultaneous processing of particle data across different processing units.</li>
            <li><strong>Spatial Partitioning:</strong> Techniques like spatial hashing or octrees can be implemented to efficiently handle neighbor searches in high-density particle simulations.</li>
            <li><strong>SIMD (Single Instruction, Multiple Data):</strong> Utilizes CPU-specific optimizations for parallel data processing, enhancing computational efficiency.</li>
        </ul>

        <h3>Future Enhancements</h3>
        <p>Potential improvements to further boost ParticleBox's capabilities include:</p>
        <ul>
            <li>GPU acceleration using CUDA or OpenCL for even higher particle counts</li>
            <li>Implementation of advanced collision detection algorithms</li>
            <li>Integration of rigid body dynamics for complex scene simulations</li>
        </ul>

        <p>These enhancements would push the boundaries of what's possible in real-time particle and fluid simulations, opening up new applications in graphics, scientific modeling, and interactive physics engines.</p>
    </section>

        </section>

        <section id="gallery" class="showcase__section">
            <h2>Project Gallery</h2>
            <div class="image-gallery">
                <img src="images/p1.gif" alt="Project screenshot 1">
                <img src="images/p2.png" alt="Project screenshot 1">
            </div>
        </section>
    </div>

    <div class="showcase__cta">
        <a href="https://github.com/aaronmcleancs/ParticleBox" class="button">View on GitHub</a>
        <a href="#" class="button">Live Demo</a>
    </div>
    <div style="text-align: center; margin-top: 20px; margin-bottom: 20px;">
        <a href="https://opensource.org/licenses/MIT" style="color: rgb(113, 113, 113); font-size: small;" target="_blank;">
            @Aaron McLean
        </a>
    </div>
    <div class="fullscreen-viewer">
        <img src="" alt="Fullscreen image" class="fullscreen-image">
        <div class="fullscreen-nav">
            <button class="fullscreen-prev">&lt;</button>
            <button class="fullscreen-next">&gt;</button>
        </div>
        <button class="fullscreen-close">&times;</button>
    </div>

    <script>
        const imageGallery = document.querySelector('.image-gallery');
        const fullscreenViewer = document.querySelector('.fullscreen-viewer');
        const fullscreenImage = document.querySelector('.fullscreen-image');
        const prevButton = document.querySelector('.fullscreen-prev');
        const nextButton = document.querySelector('.fullscreen-next');
        const closeButton = document.querySelector('.fullscreen-close');
        let currentImageIndex = 0;
        const images = Array.from(imageGallery.querySelectorAll('img'));

        function openFullscreen(index) {
            currentImageIndex = index;
            fullscreenImage.src = images[index].src;
            fullscreenViewer.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function closeFullscreen() {
            fullscreenViewer.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function showNextImage() {
            currentImageIndex = (currentImageIndex + 1) % images.length;
            fullscreenImage.src = images[currentImageIndex].src;
        }

        function showPrevImage() {
            currentImageIndex = (currentImageIndex - 1 + images.length) % images.length;
            fullscreenImage.src = images[currentImageIndex].src;
        }

        images.forEach((img, index) => {
            img.addEventListener('click', () => openFullscreen(index));
        });

        closeButton.addEventListener('click', closeFullscreen);
        nextButton.addEventListener('click', showNextImage);
        prevButton.addEventListener('click', showPrevImage);

        fullscreenViewer.addEventListener('click', (e) => {
            if (e.target === fullscreenViewer) {
                closeFullscreen();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (fullscreenViewer.style.display === 'flex') {
                if (e.key === 'Escape') closeFullscreen();
                if (e.key === 'ArrowRight') showNextImage();
                if (e.key === 'ArrowLeft') showPrevImage();
            }
        });
    </script>
    <script src="js/showcase.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>